# Step 3: Create and Populate the Movie Table

Now, we will create a **simple table** to store movie titles and their AI-generated vector embeddings.

## Why Are We Storing Movie Titles?

We will use **movie titles** as our dataset because:

1. It’s a **simple dataset** that helps focus on learning AI concepts.
2. It allows us to see **how deeply trained AI models understand relationships** between words.
3. We can use **AI-powered search** to match movies based on meaning.

## Table Structure

Create a table named `Movie` with **three columns**:

1. `MovieId` - A unique identifier.
2. `Title` - The movie title.
3. `Vector` - A **vector(1536)** column that will store AI-generated embeddings.

    - Note that the `vector` data type is available in public preview today in Azure SQL Database, but is not available in SQL Server 2022. However, it will be available in SQL Server 2025.

```sql
CREATE TABLE Movie (
    MovieId int IDENTITY PRIMARY KEY,
    Title varchar(50),
    Vector vector(1536)  -- New SQL Server vector data type
)
```

Next, insert four movies:

```sql
INSERT INTO Movie (Title) VALUES
    ('Return of the Jedi'),
    ('The Godfather'),
    ('Animal House'),
    ('The Two Towers')
```

From a pop-culture perspective, many of you might recognize these movie titles, and associate them with a wide range of attributes, such as particular phrases, actors, fictitious characters, settings, genres, and more. Just to keep the demo interesting and fun, go ahead and insert a few more titles of your own personal favorite movies.

## Vector Size Considerations

In the next step, you'll see that we are using **OpenAI's text-embedding-3-large model**, which **returns 3072-dimensional vectors**. However, **SQL Server currently only supports vectors up to 1998 dimensions**. Understand that the dimensionality of a vector determines its resolution; higher dimensionality results in higher resolution.

To fit within this limit, we will **request Azure OpenAI to compress the vectors to 1536 dimensions** by adding `'dimensions': 1536` in the API payload.

This allows us to:

- Store vectors inside a `vector(1536)` column in SQL Server.  
- Preserve **high accuracy** while reducing storage size.  
- Ensure compatibility with **SQL Server’s current vector limit**.  

This compression **minimally affects accuracy**, as OpenAI optimizes dimensionality reduction to **retain meaningful vector relationships**, while enjoying a 50% smaller storage footprint. Ultimately what this means is that, even though the "picture" is "blurred" by a loss of resolution, it's still acceptably "clear" in terms of what it represents.

## What Is a Vector?

A **vector** is a list of numbers (typically floating point numbers) that represents **semantic meaning** of a piece of text, in terms of similarity or distance. For example, notice how the **close together** the vector values of "The Godfather" and "Crime Drama" are, indicating similarity:

| Text                   | Vector Representation |
|------------------------|--------------------------------|
| "The Godfather"       | `[0.45, -0.12, 0.98, ...]`    |
| "Crime Drama"        | `[0.44, -0.10, 0.95, ...]`    |

Simply put, if two vectors are **close together**, they mean similar things. Conversely, the **farther apart** they are, the less similar they are.

## Verify the Data

Now query the table:

```sql
SELECT * FROM Movie
```

At this stage, you can see that the **Vector** column is `NULL`. In the next steps, we will **generate AI-powered embeddings** and store them in this column.

___

▶ [Step 4: Create the VectorizeText Stored Procedure](https://github.com/lennilobel/sql2022-workshop-hol-vegas2025/blob/master/HOL/4.%20AI%20Features/1.%20Vector%20Search/4.%20Create%20the%20VectorizeText%20Stored%20Procedure.md)
