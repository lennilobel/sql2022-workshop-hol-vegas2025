# RAG Solution

GPT: The previous lab demonstrated vectorizing movie titles and running vector searches. Explain how this lab will build on thre previous lab by implementing a primitive RAG pattern (include an explanation of RAG in one or two sentences). Explain that a full RAG solution goes farther than just vector search, but will actually translate the raw database results of a vector search into a natural language query response in the form of an AI assistantThis lab will be different than the previous lab in several ways: First, it will have a slightly meater dataset than just four movie titles. We'll have a Recipes database with a data model that includes several related tables populated with 50 recipes, where we'll vectorize each complete recipe entity across all columns and all related tables (not just the recipe name). And although we will use the same VectorizeText stored procedure from the previous lab to vectorize recipes and natural language user queries against an Azure OpenAI text embedding model, we will also use an Azure OpenAI chat completion model to present the raw database result as a natural language response. Please explain everything I just described in detail for the student, in about three or four paragraphs.

Make sure you are still connected to your personal `AIDB` database on `vslive-sql.database.windows.net` from the previous lab.

## Create the Tables

GPT: Ignore the next snippet.

```sql
DROP TABLE IF EXISTS Tag
DROP TABLE IF EXISTS MealType
DROP TABLE IF EXISTS Instruction
DROP TABLE IF EXISTS Ingredient
DROP TABLE IF EXISTS Recipe

IF EXISTS (SELECT * FROM sys.database_scoped_credentials WHERE name = 'BlobStorageCredential')
    DROP DATABASE SCOPED CREDENTIAL BlobStorageCredential

IF EXISTS (SELECT * FROM sys.external_data_sources WHERE name = 'BlobStorageContainer')
    DROP EXTERNAL DATA SOURCE BlobStorageContainer

IF EXISTS (SELECT * FROM sys.symmetric_keys WHERE name = '##MS_DatabaseMasterKey##')
    DROP MASTER KEY
```

GPT: Explain how this step creates multiple related tables for storing Recipes. Explain that each recipe is represented as a single row in the Recipe table, and has multiple related rows in the other tables. At this stage, it is an ordinary database with no AI capabilities.

```sql
CREATE TABLE Recipe(
  RecipeId int NOT NULL,
  RecipeName varchar(50) NOT NULL,
  PrepTimeMinutes int,
  CookTimeMinutes int,
  Servings int,
  Difficulty varchar(50),
  Cuisine varchar(50),
  CaloriesPerService int,
  Rating decimal(18, 9),
  ReviewCount int,
  CONSTRAINT PK_Recipe PRIMARY KEY CLUSTERED (RecipeId),
)

CREATE TABLE Ingredient(
  IngredientId int NOT NULL IDENTITY,
  RecipeId int NOT NULL,
  IngredientIndex int NOT NULL,
  IngredientName varchar(50) NOT NULL,
  CONSTRAINT PK_Ingredient PRIMARY KEY CLUSTERED  (IngredientId),
  CONSTRAINT FK_Recipe_Ingredient FOREIGN KEY(RecipeId) REFERENCES Recipe (RecipeId),
)

CREATE TABLE Instruction(
  InstructionId int NOT NULL IDENTITY,
  RecipeId int NOT NULL,
  InstructionIndex int NOT NULL,
  InstructionText varchar(200) NOT NULL,
  CONSTRAINT PK_Instruction PRIMARY KEY CLUSTERED (InstructionId),
  CONSTRAINT FK_Recipe_Instruction FOREIGN KEY(RecipeId) REFERENCES Recipe (RecipeId),
)

CREATE TABLE MealType(
  MealTypeId int NOT NULL IDENTITY,
  RecipeId int NOT NULL,
  MealTypeName varchar(50) NOT NULL,
  CONSTRAINT PK_MealType PRIMARY KEY CLUSTERED (MealTypeId),
  CONSTRAINT FK_Recipe_MealType FOREIGN KEY(RecipeId) REFERENCES Recipe (RecipeId),
)

CREATE TABLE Tag(
  TagId int IDENTITY(1,1) NOT NULL,
  RecipeId int NOT NULL,
  TagName varchar(50) NOT NULL,
  CONSTRAINT PK_Tag PRIMARY KEY CLUSTERED (TagId),
  CONSTRAINT FK_Recipe_Tag FOREIGN KEY(RecipeId) REFERENCES Recipe (RecipeId),
)
```

## Populate the Tables

GPT: Explain that we will populate the 50 recipes from a raw JSON file stored in Azure Blob Storage, and that the instructor will be providing a secret key in order access the file. So this next snippet defines the credentials and blob container details for the raw JSON file.

```sql
CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'Str0ngP@$$w0rd'

CREATE DATABASE SCOPED CREDENTIAL BlobStorageCredential
  WITH IDENTITY = 'SHARED ACCESS SIGNATURE',
  SECRET = '<provided by the instructor>'

CREATE EXTERNAL DATA SOURCE BlobStorageContainer
WITH (
  TYPE = BLOB_STORAGE,
  LOCATION = 'https://lennidemo.blob.core.windows.net/datasets',
  CREDENTIAL = BlobStorageCredential
)
```

GPT: Ignore the next snippet.

```sql
-- Delete data from child tables
DELETE FROM Ingredient
DELETE FROM Instruction
DELETE FROM MealType
DELETE FROM Tag

-- Delete data from the Recipe table
DELETE FROM Recipe
```

GPT: Explain that the following code uses OPENROWSET to read the raw JSON file, and then uses OPENJSON to shread the raw JSON content into one row per recipe for the Recipe table. Explain how CROSS APPLY is then used with OPENJSON to shread and store multiple individual related recipe rows into all the other tables.

```sql
-- Retrieve the raw JSON source file from blob storage
DECLARE @Json varchar(max) = (
  SELECT BulkColumn
  FROM OPENROWSET(BULK 'Recipes.json', DATA_SOURCE = 'BlobStorageContainer', SINGLE_CLOB) AS RecipesJson
)

-- Insert into the Recipe table
INSERT INTO Recipe (RecipeId, RecipeName, PrepTimeMinutes, CookTimeMinutes, Servings, Difficulty, Cuisine, CaloriesPerService, Rating, ReviewCount)
SELECT 
    JSON_VALUE(Recipe.value, '$.id') AS RecipeId,
    JSON_VALUE(Recipe.value, '$.name') AS RecipeName,
    JSON_VALUE(Recipe.value, '$.prepTimeMinutes') AS PrepTimeMinutes,
    JSON_VALUE(Recipe.value, '$.cookTimeMinutes') AS CookTimeMinutes,
    JSON_VALUE(Recipe.value, '$.servings') AS Servings,
    JSON_VALUE(Recipe.value, '$.difficulty') AS Difficulty,
    JSON_VALUE(Recipe.value, '$.cuisine') AS Cuisine,
    JSON_VALUE(Recipe.value, '$.caloriesPerServing') AS CaloriesPerService,
    JSON_VALUE(Recipe.value, '$.rating') AS Rating,
    JSON_VALUE(Recipe.value, '$.reviewCount') AS ReviewCount
FROM OPENJSON(@Json) AS Recipe

-- Insert into the Ingredient table
INSERT INTO Ingredient (RecipeId, IngredientIndex, IngredientName)
SELECT 
    JSON_VALUE(Recipe.value, '$.id') AS RecipeId,
    Ingredient.[key] AS IngredientIndex,
    Ingredient.value AS IngredientName
FROM OPENJSON(@Json) AS Recipe
CROSS APPLY OPENJSON(Recipe.value, '$.ingredients') AS Ingredient

-- Insert into the Instruction table
INSERT INTO Instruction (RecipeId, InstructionIndex, InstructionText)
SELECT 
    JSON_VALUE(Recipe.value, '$.id') AS RecipeId,
    Instruction.[key] AS InstructionIndex,
    Instruction.value AS InstructionText
FROM OPENJSON(@Json) AS Recipe
CROSS APPLY OPENJSON(Recipe.value, '$.instructions') AS Instruction

-- Insert into the MealType table
INSERT INTO MealType (RecipeId, MealTypeName)
SELECT 
    JSON_VALUE(Recipe.value, '$.id') AS RecipeId,
    MealType.value AS MealTypeName
FROM OPENJSON(@Json) AS Recipe
CROSS APPLY OPENJSON(Recipe.value, '$.mealType') AS MealType

-- Insert into the Tag table
INSERT INTO Tag (RecipeId, TagName)
SELECT 
    JSON_VALUE(Recipe.value, '$.id') AS RecipeId,
    Tag.value AS TagName
FROM OPENJSON(@Json) AS Recipe
CROSS APPLY OPENJSON(Recipe.value, '$.tags') AS Tag
```

GPT: Instruct the student to run these queries and view the rows in each table.

```sql
SELECT * FROM Recipe
SELECT * FROM Ingredient
SELECT * FROM Instruction
SELECT * FROM MealType
SELECT * FROM Tag
```

## Create a View for Complete Recipe Entities

GPT: Explain how we need to be able to join each Recipe row with all of it's related rows into a single row for vectorization. Explain how this view accomplishes this using STRING_AGG to gather related rows together into a single string for each recipe, and how ROW_NUMBER is leveraged to also number each ingredient and instruction in the generated strings.

```sql
CREATE OR ALTER VIEW RecipeView AS
SELECT 
    r.RecipeId,
    r.RecipeName,
    r.PrepTimeMinutes,
    r.CookTimeMinutes,
    r.Servings,
    r.Difficulty,
    r.Cuisine,
    r.CaloriesPerService,
    r.Rating,
    r.ReviewCount,
    Ingredients = (
        SELECT STRING_AGG(CONCAT(i.RowNum, ') ', i.IngredientName), '. ')
        FROM (
            SELECT 
                IngredientName,
                ROW_NUMBER() OVER (ORDER BY IngredientId) AS RowNum
            FROM Ingredient
            WHERE RecipeId = r.RecipeId
        ) AS i
    ),
    Instructions = (
        SELECT STRING_AGG(CONCAT(i.RowNum, ') ', i.InstructionText), ' ')
        FROM (
            SELECT 
                InstructionText,
                ROW_NUMBER() OVER (ORDER BY InstructionId) AS RowNum
            FROM Instruction
            WHERE RecipeId = r.RecipeId
        ) AS i
    ),
    MealType = (
        SELECT STRING_AGG(mt.MealTypeName, '; ')
        FROM MealType AS mt
        WHERE mt.RecipeId = r.RecipeId
    ),
    Tags = (
        SELECT STRING_AGG(t.TagName, '; ')
        FROM Tag AS t
        WHERE t.RecipeId = r.RecipeId
    )
FROM Recipe AS r
```

GPT: Let the student query the first several rows of the view. Observe how each row contains the complete description of a recipe from each Recipe row along with all of the related rows in other tables.

```sql
SELECT TOP 5 * FROM RecipeView
```

## Create a Stored Procedure to Retrieve a Recipe as JSON

GPT: Explain how we need a simple stored procedure that accepts a recipe ID, queries the view for the matching row (which includes all related entities), and formats the row as JSON. Explain that a recipe formatted as JSON makes an ideal input for the VectorizeText stored procedure we created in the previous lab, which will now vectorize an entire recipe to capture the semantic meaning of all it's properties.

```sql
CREATE OR ALTER PROCEDURE GetRecipeJson
	@RecipeId int,
	@RecipeJson nvarchar(max) OUTPUT
AS
BEGIN

	SET @RecipeJson = (
		SELECT *
		FROM RecipeView
		WHERE RecipeId = @RecipeId
		FOR JSON AUTO, WITHOUT_ARRAY_WRAPPER
	)

END
```

GPT: Try out the stored procedure for the Recipe ID 1. Observe the JSON representation of the view row.

```sql
DECLARE @RecipeJson nvarchar(max)
EXEC GetRecipeJson 1, @RecipeJson OUTPUT
SELECT @RecipeJson
```

## Vectorize the Recipes

GPT: Explain how we will now add AI capabilities to a database that, at this point, is quite ordinary. And the first step is to add vector column to the recipe table, same as the Movie table from the previous lab.

```sql
ALTER TABLE Recipe ADD Vector vector(1536)
```

GPT: Explain how the following code uses a cursor to vectorize each recipe. Explain how it works very similar to the previous lab. Explain that it simply fetches each recipe ID, calls GetRecipeJson to get the complete recipe JSON content, calls Vectorize text to obtain a vector for the entire recipe, and updates the vector in the Recipe table in the database. Also explain that this step relies on the VectorSearch stored procedure created in the previous lab.

```sql
DECLARE @RecipeId int
DECLARE @RecipeJson varchar(max)
DECLARE @Vector vector(1536)

DECLARE curRecipes CURSOR FOR
    SELECT RecipeId FROM Recipe

OPEN curRecipes
FETCH NEXT FROM curRecipes INTO @RecipeId

WHILE @@FETCH_STATUS = 0 BEGIN

	-- Get the JSON content for the recipe
	EXEC GetRecipeJson @RecipeId, @RecipeJson OUTPUT

    -- Generate vector for the recipe
    EXEC VectorizeText @RecipeJson, @Vector OUTPUT

    -- Store vector in the Recipe table
    UPDATE Recipe
    SET Vector = @Vector
    WHERE RecipeId = @RecipeId

    FETCH NEXT FROM curRecipes INTO @RecipeId
END

CLOSE curRecipes
DEALLOCATE curRecipes
```

GPT: Have the student query the Recipe table to observe the populated Vector column.

```sql
SELECT * FROM Recipe
```

# Create a Stored Procedure to Run a Vector Search

GPT: Explain that we are now creating a vector search stored procedure that works very similar to the one fromt the previous lab. While the one from the previous lab used TOP 1 to find just the closest match, here we are returning the TOP 5 recipes sorted from closest match to farthest match.

```sql
CREATE OR ALTER PROCEDURE RecipeVectorSearch
    @Question varchar(max)
AS
BEGIN
    -- Prepare a vector variable to capture the question vector components
    DECLARE @QuestionVector vector(1536)

    -- Vectorize the question using Azure OpenAI
    EXEC VectorizeText @Question, @QuestionVector OUTPUT

    -- Find the most similar recipes based on cosine similarity
    SELECT TOP 5
		rv.*,
        CosineDistance = VECTOR_DISTANCE('cosine', @QuestionVector, r.Vector)
    FROM
		Recipe AS r
		INNER JOIN RecipeView AS rv ON rv.RecipeId = r.RecipeId
    ORDER BY CosineDistance
END
```

GPT: Have the user try it out with these sample queries. Explain what to expect and what to observe. 

```sql
EXEC RecipeVectorSearch 'How about some Italian appetizers?'
EXEC RecipeVectorSearch 'Show me your pizza recipes'
EXEC RecipeVectorSearch 'Please recommend delicious Italian desserts'
EXEC RecipeVectorSearch 'Fresh Mediterranean salad options'
EXEC RecipeVectorSearch 'I love chicken, kebab, and falafel'
EXEC RecipeVectorSearch 'Stir fry'
EXEC RecipeVectorSearch 'Asian stir fry'
EXEC RecipeVectorSearch 'Soup'
EXEC RecipeVectorSearch 'Ramen'
EXEC RecipeVectorSearch 'Breakfast meals'
EXEC RecipeVectorSearch 'Korean breakfast'
EXEC RecipeVectorSearch 'Pineapple in the ingredients'
EXEC RecipeVectorSearch 'Tomato sauce in the ingredients'
EXEC RecipeVectorSearch 'Lunch recipes'
EXEC RecipeVectorSearch 'Cook time less than 30 minutes'
EXEC RecipeVectorSearch 'American dessert'
EXEC RecipeVectorSearch 'Easy dessert'
EXEC RecipeVectorSearch 'Pakistani cuisine'
EXEC RecipeVectorSearch 'Turkish cuisine'
EXEC RecipeVectorSearch 'Thai cuisine'
EXEC RecipeVectorSearch 'Fewest calories'
EXEC RecipeVectorSearch 'I love ginger'
EXEC RecipeVectorSearch 'How about a nice snack?'
EXEC RecipeVectorSearch 'Salad for 6 servings'
EXEC RecipeVectorSearch 'A good dish, but no garlic in the ingredients'
```

# Create a JSON Version of the Vector Search Stored Procedure

GPT: Explain how this stored procedure is virtually identical to the previous one, but returns the results as a raw JSON string, holding an array with one object for each recipe result. Explain that we need this version of the stored procedure in order to capture all the database results in a string that we can send on to the chat completions model in the next step.

```sql
CREATE OR ALTER PROCEDURE RecipeVectorSearchJson
    @Question varchar(max)
AS
BEGIN
    -- Prepare a vector variable to capture the question vector components
    DECLARE @QuestionVector vector(1536)

    -- Vectorize the question using Azure OpenAI
    EXEC VectorizeText @Question, @QuestionVector OUTPUT

    -- Find the most similar recipes based on cosine similarity
	DECLARE @JsonResults nvarchar(max) = (
		SELECT TOP 10
			rv.*,
			CosineDistance = VECTOR_DISTANCE('cosine', @QuestionVector, r.Vector)  -- New T-SQL function
		FROM
			Recipe AS r
			INNER JOIN RecipeView AS rv ON rv.RecipeId = r.RecipeId
		WHERE
			VECTOR_DISTANCE('cosine', @QuestionVector, r.Vector) < .65
		ORDER BY CosineDistance
		FOR JSON AUTO
	)

	SELECT JsonResults = @JsonResults
END
```

GPT: Have the user try out both stored procedures using the same question text. Observe that the JSON returned by the second stored procedure represents the tabular content returned by the first stored procedure.

```sql
EXEC RecipeVectorSearch 'I love chicken, kebab, and falafel'
EXEC RecipeVectorSearchJson 'I love chicken, kebab, and falafel'
```

# Create a Stored Procedure for Chat Completion

GPT: Explain that we're now creating a stored procedure to call the gpt-4o chat completion model in Azure OpenAI. Observe the similarity to the VectorizeText stored procedure, with the following notable differences: 1) the deploymant points to gpt-4o, the @Url parameter points to /chat/completions, and the @Payload parameter includes system and user messages (where the user message is passed in to the stored procedure as the @Question parameter), as well as additional settings that control the demeanor, temprament, and behavior of the chat responses.

Also explain that the OpenAI API key should be replaced with the same key used by the VectorizeText stored procedure in the previous lab.

```sql
CREATE OR ALTER PROCEDURE GetChatCompletion
    @Question varchar(max),
    @ResponseText varchar(max) OUTPUT
AS
BEGIN
    -- Azure OpenAI endpoint
    DECLARE @OpenAIEndpoint varchar(max) = 'https://lenni-m6wi7gcd-eastus2.cognitiveservices.azure.com/'
    DECLARE @OpenAIDeploymentName varchar(max) = 'gpt-4o'  -- Use the appropriate GPT model deployment name
    DECLARE @OpenAIVersion varchar(max) = '2023-05-15'
    DECLARE @Url varchar(max) = CONCAT(@OpenAIEndpoint, 'openai/deployments/', @OpenAIDeploymentName, '/chat/completions?api-version=', @OpenAIVersion)

    -- Azure OpenAI API key
    DECLARE @OpenAIApiKey varchar(max) = '<provided by the instructor>'
    DECLARE @Headers varchar(max) = JSON_OBJECT('api-key': @OpenAIApiKey)

    -- Payload for chat completion request
    DECLARE @Payload varchar(max) = JSON_OBJECT(
        'messages': JSON_ARRAY(
            JSON_OBJECT('role': 'system', 'content': 'You are an assistant that helps people find recipes from a database.'),
            JSON_OBJECT('role': 'user', 'content': @Question)
        ),
        'max_tokens': 1000,			-- Max number of tokens for the response; the more tokens you specify (spend), the more verbose the response
        'temperature': 1.0,			-- Range is 0.0 to 2.0; controls "apparent creativity"; higher = more random, lower = more deterministic
        'frequency_penalty': 0.0,	-- Range is -2.0 to 2.0; controls likelihood of repeating words; higher = less likely, lower = more likely
        'presence_penalty': 0.0,	-- Range is -2.0 to 2.0; controls likelihood of introducing new topics; higher = more likely, lower = less likely
        'top_p': 0.95				-- Range is 0.0 to 2.0; aka "Top P sampling"; temperature alternative; controls diversity of responses (1.0 is full random, lower values limit randomness)
	)

    -- Response and return value
    DECLARE @Response nvarchar(max)
    DECLARE @ReturnValue int

    -- Call Azure OpenAI to get chat response
    EXEC @ReturnValue = sp_invoke_external_rest_endpoint
        @url = @Url,
        @method = 'POST',
        @headers = @Headers,
        @payload = @Payload,
        @response = @Response OUTPUT

    -- Print raw JSON response to the console
    --PRINT @Response

    -- Handle API errors
    IF @ReturnValue != 0
        THROW 50000, @Response, 1

    -- Extract the assistant's reply from the JSON response
    SET @ResponseText = JSON_VALUE(@Response, '$.result.choices[0].message.content')
END
```

# Create the AI Assistant Stored Procedure

GPT: Explain how the AskRecipeQuestion stored procedure ties everything together to provide a chat based AI assistant for finding recipes in the database. Explain how it accepts a natural language question, calls the JSON version of the recipe vector search stored procedure using INSERT INTO to capture the JSON result to a JSON string variable using a table variable. Then explain how we construct a user prompt to help humanize the chat response. Observe how the user prompt tells the GPT model to preface each response with something related to the user's query, followed by each database result formatted in a very specific manner.

```sql
CREATE OR ALTER PROCEDURE AskRecipeQuestion @Question nvarchar(max)
AS
BEGIN

	SET NOCOUNT ON

	DECLARE @JsonResultsTable table (JsonResults nvarchar(max))
	INSERT INTO @JsonResultsTable EXEC RecipeVectorSearchJson @Question
	DECLARE @JsonResults nvarchar(max) = (SELECT JsonResults FROM @JsonResultsTable)

	DECLARE @UserPrompt nvarchar(max) = CONCAT('
		The user asked the question "', @Question, '" and the database returned recipes below.
		Generate a response that starts with a sentence or two related to the user''s question,
		followed by each recipe''s details. For the details, list the ingredients as a comma-separated
		string, and list the instructions as a numbered list:
		', @JsonResults
	)

	DECLARE @ResponseText nvarchar(max)
	EXEC GetChatCompletion @UserPrompt, @ResponseText OUTPUT
	PRINT @ResponseText

END
```

GPT: Last step of the lab! Have the user try it out with these example:

```
```

